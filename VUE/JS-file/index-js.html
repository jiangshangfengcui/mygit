<!DOCTYPE html>
<!-- saved from url=(0044)file:///D:/E-Disc/study/mygit/VUE/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<title>Document</title>

	<style>
		/*app-43*/
		.fade-enter-active, .fade-leave-active {
		  transition: opacity .5s;
		}
		.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
		  opacity: 0;
		}

		/* app-44 */
		/* 可以设置不同的进入和离开动画 */
		/* 设置持续时间和动画函数 */
		.slide-fade-enter-active {
		  transition: all .3s ease;
		}
		.slide-fade-leave-active {
		  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
		}
		.slide-fade-enter, .slide-fade-leave-to
		/* .slide-fade-leave-active for below version 2.1.8 */ {
		  transform: translateX(10px);
		  opacity: 0;
		}

		/* app-45 */
		.bounce-enter-active {
		  animation: bounce-in .5s;
		}
		.bounce-leave-active {
		  animation: bounce-in .5s reverse;
		}
		@keyframes bounce-in {
		  0% {
		    transform: scale(0);
		  }
		  50% {
		    transform: scale(1.5);
		  }
		  100% {
		    transform: scale(1);
		  }
		}

		/* app-52 */
		.no-mode-fade-enter-active, .no-mode-fade-leave-active {
		  transition: opacity .5s
		}
		.no-mode-fade-enter, .no-mode-fade-leave-active {
		  opacity: 0
		}

	</style>
	<style>
		/* 在元素绝对定位在彼此之上的时候运行正常： */
		.no-mode-absolute-demo-wrapper {
		  position: relative;
		  height: 18px;
		}
		.no-mode-absolute-demo-wrapper button {
		  position: absolute;
		}
		.no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active {
		  transition: opacity .5s;
		}
		.no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active {
		  opacity: 0;
		}
		/* no-mode-translate-demo */
		.no-mode-translate-demo-wrapper {
		  position: relative;
		  height: 18px;
		}
		.no-mode-translate-demo-wrapper button {
		  position: absolute;
		}
		.no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active {
		  transition: all 1s;
		}
		.no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active {
		  opacity: 0;
		}
		.no-mode-translate-fade-enter {
		  transform: translateX(31px);
		}
		.no-mode-translate-fade-leave-active {
		  transform: translateX(-31px);
		}

		/* app-53 */

		.with-mode-fade-enter-active, .with-mode-fade-leave-active {
		  transition: opacity .5s
		}
		.with-mode-fade-enter, .with-mode-fade-leave-active {
		  opacity: 0
		}

		/* app-55 */
		.component-fade-enter-active, .component-fade-leave-active {
		  transition: opacity .3s ease;
		}
		.component-fade-enter, .component-fade-leave-to
		/* .component-fade-leave-active for below version 2.1.8 */ {
		  opacity: 0;
		}

		/* app-56 */
		.list-item {
		  display: inline-block;
		  margin-right: 10px;
		}
		.list-enter-active, .list-leave-active {
		  transition: all 1s;
		}
		.list-enter, .list-leave-to
		/* .list-leave-active for below version 2.1.8 */ {
		  opacity: 0;
		  transform: translateY(30px);
		}

		/* app-57 */
		.flip-list-move {
		  transition: transform 1s;
		}

		/* app-58 */
		.list-complete-item {
		  transition: all 1s;
		  display: inline-block;
		  margin-right: 10px;
		}
		.list-complete-enter, .list-complete-leave-to
		/* .list-complete-leave-active for below version 2.1.8 */ {
		  opacity: 0;
		  transform: translateY(30px);
		}
		.list-complete-leave-active {
		  position: absolute;
		}

		/* app-59 */
		.sudoku-container {
		  display: flex;
		  flex-wrap: wrap;
		  width: 238px;
		  margin-top: 10px;
		}
		.cell {
		  display: flex;
		  justify-content: space-around;
		  align-items: center;
		  width: 25px;
		  height: 25px;
		  border: 1px solid #aaa;
		  margin-right: -1px;
		  margin-bottom: -1px;
		}
		.cell:nth-child(3n) {
		  margin-right: 0;
		}
		.cell:nth-child(27n) {
		  margin-bottom: 0;
		}
		.cell-move {
		  transition: transform 1s;
		}

		/* app-60 */
		.very-special-transition-enter-active, .very-special-transition-leave-active {
		  transition: opacity .5s;
		}
		.very-special-transition-enter, .very-special-transition-leave-to /* .fade-leave-active below version 2.1.8 */ {
		  opacity: 0;
		}
	</style>
</head>
<body>
	<div id="app">
	  Hello Vue!
	</div>
	
	<!-- bind 属性值 -->
	<div id="app-2"><span title="页面加载于 2018/4/27 上午10:13:07">                
	    鼠标悬停几秒钟查看此处动态绑定的提示信息！
	  </span></div>
	
	<!-- v-if 插入删除-->
	<div id="app-3"><p>现在你看到我了</p></div>

	<!-- for -->
	<div id="app-4"><ol><li>
	      学习 JavaScript
	    </li><li>
	      学习 Vue
	    </li><li>
	      整个牛项目
	    </li></ol></div>

	<!-- v-on:click 绑定事件 -->
	<div id="app-5"><p>Hello Vue.js!</p> <button>逆转消息</button></div>

	<!-- v-mode 双向绑定 -->
	<!-- 它能轻松实现表单输入和应用状态之间的双向绑定 -->
	<div id="app-6"><p>Hello Vue!</p> <input></div>

	<!-- 引用自定义的组件 todo-item -->
	<ol>
	  <!-- 创建一个 todo-item 组件的实例 -->
	  <todo-item></todo-item>
	</ol>

	<div id="app-7"><ol><li>蔬菜</li><li>奶酪</li><li>随便其它什么人吃的东西</li></ol></div>


	<div id="app-8"><span>Message: 插值&lt;span&gt;&lt;/span&gt;</span> <span>这个将不会改变: 插值&lt;span&gt;&lt;/span&gt;</span></div>

	<div id="app-9"><p>Using mustaches: &lt;span style="color:red"&gt; This should be red.&lt;/span&gt;</p> <p>Using v-html directive: <span><span style="color:red"> This should be red.</span></span></p></div>

	<div>
		<!-- 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 <button> 元素中。 -->
		<!-- 绑定的 简单表达式 -->
		<button v-bind:disabled="isButtonDisabled">Button</button>
	</div>

	<div id="app-10"><form>...
			<input type="submit" value="提交"></form></div>

	<div id="app-11"><a href="http://www.baidu.com/">...</a> <a href="http://www.baidu.com/">...</a> <a>.测试this是谁..</a> <a>...</a></div>

	<div id="example"><p>Original message: "Hello"</p> <p>Computed reversed message: "olleH"</p> <button>1524795187282</button></div>

	<div id="demo"><div id="demo">Foo Bar</div></div>

	<div id="watch-example"><p>
	    Ask a yes/no question:
	    <input></p> <p>I cannot give you an answer until you ask a question!</p></div>

	<!-- 动态控制class, 于class共存 -->
	<div id="app-12"><div class="static active text-danger"></div> <div class="active text-danger"></div> <div class="active text-danger"></div> <div class="active text-danger"></div></div>

	<!-- 此处定义的class会合并到模版元素上 -->
	<my-component class="baz boo" v-bind:class="{ active: isActive }"></my-component>
	
	<div id="app-13"><div style="color: red; font-size: 30px;">v-bind:style动态样式</div> <div style="color: red; font-size: 13px;">nihao</div> <div style="color: red; border: 1px solid black; background: rgb(255, 0, 255);"></div></div>

	<div id="app-14"><h1>Title</h1> <p>Paragraph 1</p> <p>Paragraph 2</p> <div>
		  Now you see me
		</div> <div>
		  B
		</div></div>

	<div id="app-15"><label>Username</label> <input placeholder="Enter your username"> <button>Toggle login type</button> <label>Username</label> <input placeholder="Enter your username"></div>

	<div id="app-16"><h1>Hello!</h1> <div style="height: 50px; border: 2px solid red;"></div></div>
	
	<!-- v-for -->
	<div id="app-17"><ul id="example-01"><li>
		    Foo
		  </li><li>
		    newValue
		  </li><li>
		    newValue2
		  </li></ul> <ul id="example-2"><li>
		    Parent - 0 - Foo
		  </li><li>
		    Parent - 1 - Bar
		  </li></ul> <div></div><div></div><div></div> <ul id="v-for-object" class="demo"><li>
		    John
		  </li><li>
		    Doe
		  </li><li>
		    38
		  </li></ul> <div>
		  firstName: John
		</div><div>
		  lastName: Doe
		</div><div>
		  age: 38
		</div> <div></div><div></div><div></div></div>


	<div id="app-18"><li>2</li><li>4</li> <div><span>1 </span><span>2 </span><span>3 </span><span>4 </span><span>5 </span><span>6 </span><span>7 </span><span>8 </span><span>9 </span><span>10 </span></div></div>
	
	<!-- v-for 用于template -->
	<ul id="app-19"><li></li> <li class="divider"></li><li></li> <li class="divider"></li><li></li> <li class="divider"></li> <li>
	    {
  "isComplete": false
}
	  </li></ul>

	<div id="todo-list-example"><input placeholder="Add a todo"> <ul><li>		      Do the dishes		      <button>X</button> <button>Do the dishesmodify4444</button></li><li>		      Take out the trash		      <button>X</button> <button>Take out the trashmodify4444</button></li><li>		      Mow the lawn		      <button>X</button> <button>Mow the lawnmodify4444</button></li></ul></div>

	<!-- 监听事件 -->
	<!-- v-on:click 代码、函数名、say('hi') -->
	<div id="example-1"><button>Add 1</button> <p>The button above has been clicked 0 times.</p> <button>Greet</button> <button>Say hi</button> <button>
	    Submit
	  </button></div>

	<!-- 
		.stop 		event.stopPropagation()
		.prevent 	event.preventDefault()
		.capture
		.self
		.once
	 -->
	<div id="app-20">
		<!-- 阻止单击事件继续传播 -->
		<a v-on:click.stop="doThis"></a>

		<!-- 提交事件不再重载页面 -->
		<form v-on:submit.prevent="onSubmit"></form>

		<!-- 修饰符可以串联 -->
		<a v-on:click.stop.prevent="doThat"></a>

		<!-- 只有修饰符 -->
		<form v-on:submit.prevent=""></form>

		<!-- 添加事件监听器时使用事件捕获模式 -->
		<!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 -->
		<div v-on:click.capture="doThis">...</div>

		<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
		<!-- 即事件不是从内部元素触发的 -->
		<div v-on:click.self="doThat">...</div>

		<!-- 点击事件将只会触发一次 2.1.4 新增-->
		<a v-on:click.once="doThis"></a>

		<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 2.3.0 新增 -->
		<!-- 而不会等待 `onScroll` 完成  -->
		<!-- 这其中包含 `event.preventDefault()` 的情况 -->
		<!-- 这个 .passive 修饰符尤其能够提升移动端的性能。 -->
		<div v-on:scroll.passive="onScroll">...</div>
		
		<!-- 按键修饰符 -->
		<!-- 
			.enter
			.tab
			.delete (捕获“删除”和“退格”键)
			.esc
			.space
			.up
			.down
			.left
			.right
		 -->
		<!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` -->
		<input v-on:keyup.13="submit">
		<!-- 同上 -->
		<input v-on:keyup.enter="submit">
		<!-- 缩写语法 -->
		<input @keyup.enter="submit">
		<!-- 处理函数仅在 $event.key === 'PageDown' 时被调用 2.5.0 新增 -->
		<input @keyup.page-down="onPageDown">

		<!-- 系统修饰键 2.1.0 新增 -->
		<!-- 
			.ctrl
			.alt
			.shift
			.meta
		 -->
		 <!-- 
			注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。
		  -->
		  <!-- Alt + C -->
		  <input @keyup.alt.67="clear">
		  <!-- Ctrl + Click -->
		  <div @click.ctrl="doSomething">Do something</div>

		  <!-- .exact 修饰符 2.5.0 新增 -->
		  <!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
		  <button @click.ctrl="onClick">A</button>
		  <!-- 有且只有 Ctrl 被按下的时候才触发 -->
		  <button @click.ctrl.exact="onCtrlClick">A</button>
		  <!-- 没有任何系统修饰符被按下的时候才触发 -->
		  <button @click.exact="onClick">A</button>

		  <!-- 鼠标按钮修饰符 2.2.0 新增 -->
			<!-- 
				.left
				.right
				.middle
			 -->

		<!-- 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 -->
	</div>


	<!-- v-model -->
	<div id="app-21"><input placeholder="edit me"> <p>Message is: </p> <span>Multiline message is:</span> <p style="white-space: pre-line;"></p> <br> <textarea placeholder="add multiple lines"></textarea> <input type="checkbox" id="checkbox"> <label for="checkbox"></label> <input type="checkbox" id="jack" value="Jack"> <label for="jack">Jack</label> <input type="checkbox" id="john" value="John"> <label for="john">John</label> <input type="checkbox" id="mike" value="Mike"> <label for="mike">Mike</label> <br> <span>Checked names: []</span> <input type="radio" id="one" value="One"> <label for="one">One</label> <br> <input type="radio" id="two" value="Two"> <label for="two">Two</label> <br> <span>Picked: </span> <select><option disabled="disabled" value="">请选择</option> <option>A</option> <option>B</option> <option>C</option></select> <span>Selected: </span> <select multiple="multiple" style="width: 50px;"><option>A</option> <option>B</option> <option>C</option></select> <br> <span>Selected: []</span> <select><option value="A">
		            One
		          </option><option value="B">
		            Two
		          </option><option value="C">
		            Three
		          </option></select> <span>Selected: A</span> <input type="checkbox" true-value="yes" false-value="no"> <input type="radio" value="a"> <select><option value="[object Object]">123</option></select> <input> <input type="number"> <input type="text"></div>

	<div id="app-22">
		<my-row>...</my-row><table>
		  
		</table>
		<!-- 自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性： -->
		<table>
		  <tbody><tr is="my-row"></tr>
		</tbody></table>
	</div>
	
	<div id="app23">
		<div>
		  <simple-counter></simple-counter>
		  <simple-counter></simple-counter>
		  <simple-counter></simple-counter>
		</div>
	</div>

	<div id="app-24"><span>hello!</span></div>

	<div id="app-25"><div id="prop-example-2"><input> <br> <span>Message from parent</span></div> <span data-3d-date-picker="true">Learn Vue false Learn Vuekkkkkkkk</span></div>

	<div id="app-26"><span value="nihao" class="form-control date-picker-theme-dark"> 99</span></div>

	<!-- 父组件监听子组件事件 -->
	<!-- increment 为自定义事件名 -->
	<div id="counter-event-example"><p>0</p> <button>0</button> <button>0</button></div>
	
	<!-- padyload 载荷 -->
	<div id="message-event-example" class="demo"> <div><input type="text"> <button>Send</button></div></div>

	<!-- 给组件绑定原生事件 -->

	<!-- 你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native -->
	<my-component v-on:click.native="doTheThing"></my-component>

	<!-- .sync 修饰符  2.3.0+ -->
	<div id="app-27">
		<comp v-bind.sync="{ foo: 1, bar: 2 }"></comp>
	</div>

	<!-- v-model 语法糖 -->
	<input v-model="something">
	<input v-bind:value="something" v-on:input="something = $event.target.value">
	<custom-input v-bind:value="something" v-on:input="something = arguments[0]">
	</custom-input>

	<div id="app-28"><span>		      $		      <input></span></div>
	
	<div id="app-29"><div><input><span>false</span></div> <div><input><span>false</span></div></div>

	<div id="app-30"><button>brathor1</button> <button>brathor2init</button></div>
	

	<div id="app-31"><div><h1>我是父组件的标题</h1><div><h2>我是子组件的标题</h2><p>这是一些初始内容</p><p>这是另外一些初始内容</p></div></div></div>

	<div id="app-32"><div class="container"><header><h1>这是一个页面的标题</h1></header> <main> <p>主要内容的一个段落</p> <p>主要内容的另外一个段落</p> </main> <footer><p>这是一些页脚信息</p></footer></div></div>
	
	<!-- 作用域插槽 -->
	<div id="app-33"><div class="container"><p>动物列表</p><ul><li class="child-ul">大象</li><li class="child-ul">小狗</li><li class="child-ul">小猫</li><li class="child-ul">老虎</li></ul></div></div>
	
	<!-- 
		<test-one id="testone"></test-one>
		new Vue({
			el: 'testone',
			data: {},
			template: "<span></span>"
		}) // 							直接对自定义的组件实例化报错，实例只能挂在到已有的真实element上
	 -->

	<!-- 组件嵌套 -->
	
	<div id="app-34"><div>父组件<div>子组件<div>仔仔组件</div></div></div></div>

	<div id="app-35"><div>父组件<div>子组件<div>仔仔组件</div></div></div></div>

	<!-- 动态组件 -->
	<!-- 对其 is 特性进行动态绑定，你可以在同一个挂载点动态切换多个组件 -->
	<div id="app-36"><span>home</span></div>

	<!-- 也可以直接绑定到组件对象上： -->
	<div id="app-37"><p>Welcome home!</p></div>


	<!-- keep-alive 指令 -->
	<div id="app-38"><p>Welcome keep-alive Home!</p></div>

	<!-- 子组件引用 -->
	<!--  JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个引用 ID -->
	<div id="app-39"><div>我是局部组件，通过ref可以获取我</div></div>

	<div id="app-40"><div>I am async!</div></div>

	<div id="app-41">
		<tree-folder></tree-folder>
	</div>


	<!-- inline-template  使用inline-template指令后定义的组件字符串不起作用 -->
	<!-- 但是 inline-template 让模板的作用域难以理解。使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素才是最佳实践。 -->
	<div id="app-42"><div><p>这些将作为组件自身的模板。</p> <p>而非父组件透传进来的内容。</p></div></div>

	<!-- X-Template -->
	<script type="text/x-template" id="hello-world-template">
	  <p>Hello hello hello</p>
	</script>

	<!-- 对低开销的静态组件使用 v-once -->
	<script type="text/x-template" id="cache">
	    <div v-once>
	      <h1>Terms of Service</h1>
	      ...很多静态内容...
	    </div>
	</script>

	<!-- 单元素/组件的过渡 -->
	<!-- Vue 提供了 transition 的封装组件 -->
	<div id="app-43"><button>
	    	Toggle
	 	</button> <p>hello</p></div>

	<!-- 
		Vue处理插入删除包含在transition组件中的元素时，先检测是否应用了css过渡或动画，在检测组件是否提供了javascript钩子函数，如果没有会立即执行

		在进入/离开的过渡中，会有 6 个 class 切换：

			v-enter 		定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除
			v-enter-active	定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在
							transition/animation完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数
			v-enter-to：2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效 (与此同时 v-
							enter 被删除)，在 transition/animation 完成之后移除
			v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除
			v-leave-active：定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在
							transition/animation完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数
			v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效 (与此同时 v-
							leave 被删除)，在 transition/animation 完成之后移除
			
			注意：在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 <transition name="my-transition"> 可以重置前缀，比如 v-enter 替换为 my-transition-enter
	 -->

	 <!-- CSS 过渡 -->
	 <div id="app-44"><button>
	     	Toggle render
	   	</button> <p>hello</p></div>

	 <!-- CSS 动画 -->
	<div id="app-45"><button>Toggle show</button> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.</p></div>

	<!-- 自定义过渡的类名 -->
	<!-- 
		enter-class
		enter-active-class
		enter-to-class (2.1.8+)
		leave-class
		leave-active-class
		leave-to-class (2.1.8+)
	 -->
	<div id="app-46"><button>
	     	Toggle render
	   	</button> <p>hello</p></div>
	<!-- 
		animated.css 中 ，

			.animated {
			    -webkit-animation-duration: 1s;
			    animation-duration: 1s;
			    -webkit-animation-fill-mode: both;
			    animation-fill-mode: both /*  none|forwards(动画结束状态样式为最后一帧样式)|backwards(动画等待状态样式为第一帧动画样式)|both */ 
			}
			.tada {
			    -webkit-animation-name: tada;
			    animation-name: tada
			}
			@-webkit-keyframes tada {/* animation-name */
			    0% {
			        -webkit-transform: scaleX(1);
			        transform: scaleX(1)
			    }

			    10%,20% {
			        -webkit-transform: scale3d(.9,.9,.9) rotate(-3deg);
			        transform: scale3d(.9,.9,.9) rotate(-3deg)
			    }

			    30%,50%,70%,90% {
			        -webkit-transform: scale3d(1.1,1.1,1.1) rotate(3deg);
			        transform: scale3d(1.1,1.1,1.1) rotate(3deg)
			    }

			    40%,60%,80% {
			        -webkit-transform: scale3d(1.1,1.1,1.1) rotate(-3deg);
			        transform: scale3d(1.1,1.1,1.1) rotate(-3deg)
			    }

			    to {
			        -webkit-transform: scaleX(1);
			        transform: scaleX(1)
			    }
			}
		
	 -->

	<!-- 同时使用过渡和动画 -->
	<!-- TODO -->

	<!-- 显性的过渡持续时间 2.2.0 新增 -->
	<div id="app-47"><button>
	     	Toggle duration
	   	</button> <p>hello</p> <p>hello</p></div>

	<!-- JavaScript 钩子 -->
	<div id="app-48"><button>
	     	Toggle javascript hooks
	   	</button> <p>hello</p></div>

	<!-- 一个 Velocity.js 简单例子 -->
	<div id="app-49"><button>
	    	Toggle Velocity.js example
	  	</button> <p>
	      	Demo
	    	</p></div>

	<!-- 初始渲染的过渡 -->
	<!-- 可以通过 appear 特性设置节点在初始渲染的过渡 -->
	<div id="app-50"><button>
	    	Toggle appear
	  	</button> <p style="opacity: 1; transform-origin: left center 0px; font-size: 1em;">
	      	Demo
	    	</p></div>

	<!-- 多个元素的过渡 -->
	<!-- 
		transition 只能用于单个元素， 多个元素用transition-group 子元素必须有唯一的key
	 -->
	<div id="app-51"><button>
	    	Toggle multiply elements
	  	</button> <span><table></table><button>
	  	      fEdit
	  	  </button><button>
	  	      SaveD
	  	  </button><button>
	  	      Save
	  	    </button></span></div>

	<!-- 过渡模式 in-out out-in -->
	<div id="app-52"><button>
	    	Toggle multiply elements
	  	</button> <button>
	  	      on
	  	    </button> <div class="no-mode-absolute-demo-wrapper"><button>
	  	  	      	on
	  	  	    </button></div> <div class="no-mode-translate-demo-wrapper"><button>
  		            on
  		        </button></div></div>

	<div id="app-53"><button>on</button></div>
	<div id="app-54"><div class="no-mode-translate-demo-wrapper"><button>
			            on
			        </button></div></div>

	<!-- 多个组件的过渡 我们只需要使用动态组件 -->
	<div id="app-55"><button>Toggle component A &lt;==&gt; B</button> <div>Component A</div></div>

	<!-- 列表过渡	 -->
	<!-- 列表的进入/离开过渡 -->
	<div id="app-56" class="demo"><button>Add</button> <button>Remove</button> <p><span class="list-item">
	  	  	  1
	  	  	</span><span class="list-item">
	  	  	  2
	  	  	</span><span class="list-item">
	  	  	  3
	  	  	</span><span class="list-item">
	  	  	  4
	  	  	</span><span class="list-item">
	  	  	  5
	  	  	</span><span class="list-item">
	  	  	  6
	  	  	</span><span class="list-item">
	  	  	  7
	  	  	</span><span class="list-item">
	  	  	  8
	  	  	</span><span class="list-item">
	  	  	  9
	  	  	</span></p></div>

	<!-- 列表的排序过渡 -->
	<div id="app-57"><div id="flip-list-demo" class="demo"><button>Shuffle</button> <ul><li>
			      1
			    </li><li>
			      2
			    </li><li>
			      3
			    </li><li>
			      4
			    </li><li>
			      5
			    </li><li>
			      6
			    </li><li>
			      7
			    </li><li>
			      8
			    </li><li>
			      9
			    </li></ul></div></div>
	
	<!-- 结合以上俩个例子 -->
	<!-- 
		需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中
	 -->
	<div id="app-58" class="demo"><button>Shuffle</button> <button>Add</button> <button>Remove</button> <p><span class="list-complete-item">
	      1
	    </span><span class="list-complete-item">
	      2
	    </span><span class="list-complete-item">
	      3
	    </span><span class="list-complete-item">
	      4
	    </span><span class="list-complete-item">
	      5
	    </span><span class="list-complete-item">
	      6
	    </span><span class="list-complete-item">
	      7
	    </span><span class="list-complete-item">
	      8
	    </span><span class="list-complete-item">
	      9
	    </span></p></div>

	<div id="app-59"><div id="sudoku-demo" class="demo"><strong>Lazy Sudoku</strong> <p>Keep hitting the shuffle button until you win.</p> <button>
		    	Shuffle
		  	</button> <div class="sudoku-container"><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div><div class="cell">
			      		1
			   		</div><div class="cell">
			      		2
			   		</div><div class="cell">
			      		3
			   		</div><div class="cell">
			      		4
			   		</div><div class="cell">
			      		5
			   		</div><div class="cell">
			      		6
			   		</div><div class="cell">
			      		7
			   		</div><div class="cell">
			      		8
			   		</div><div class="cell">
			      		9
			   		</div></div></div></div>

	<!-- 可复用的过渡 -->
	<div id="app-60"><button>on</button></div>
	
	<!-- 列表的交错过渡 -->
	<!-- 没明白 -->
	<div id="app-61"><div id="staggered-list-demo"><input> <ul><li data-index="0">Bruce Lee</li><li data-index="1">Jackie Chan</li><li data-index="2">Chuck Norris</li><li data-index="3">Jet Li</li><li data-index="4">Kung Fury</li></ul></div></div>

	<!-- 动态过渡 -->
	<!-- 在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name 特性来绑定动态值。 -->
	<div>
		<transition v-bind:name="transitionName">
		  <!-- ... -->
		</transition>	
	</div>
	<!-- 可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果 -->
	<div id="app-62" class="demo">
	  Fade In: <input type="range" min="0" max="1500">
	  Fade Out: <input type="range" min="0" max="1500"> <p class="" style="opacity: 1;">hello</p> <button>Start animating</button></div>

	<div id="app-63">
		<div id="animated-number-demo"><input type="number" step="20"> <p>0</p></div>
	</div>

	<div id="app-64"><span style="font-size: 26px;">44</span></div>


	<script src="./index-js_files/vue.js.下载"></script>
	<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
	<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->
	<script src="./index-js_files/axios.min.js.下载"></script>
	<script src="./index-js_files/lodash.min.js.下载"></script>
	<!-- javascript animation -->
	<!-- 它能和 jQuery 完美协作，并和$.animate()有相同的 API， 但它不依赖 jQuery，可单独使用 -->
	<!-- Velocity 不仅包含了 $.animate() 的全部功能， 还拥有：颜色动画、转换动画(transforms)、循环、 缓动、SVG 动画、和 滚动动画 等特色功能 -->
	<!-- 它比 $.animate() 更快更流畅，性能甚至高于 CSS3 animation -->
	<script src="./index-js_files/velocity.min.js.下载"></script>
	<!-- Animate.css是一个有趣的，跨浏览器的css3动画库 -->
	<link rel="stylesheet" href="./index-js_files/animate.min.css">
  	<!-- or -->
  	<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css"> 加载太慢  -->
  	<script src="./index-js_files/TweenMax.min.js.下载"></script>


	<script>

		

		var app = new Vue({
		  el: '#app',
		  data: {
		    message: 'Hello Vue!'
		  }
		});

		var app2 = new Vue({
		  el: '#app-2',
		  data: {
		    message: '页面加载于 ' + new Date().toLocaleString()
		  }
		})

		var app3 = new Vue({
		  el: '#app-3',
		  data: {
		    seen: true
		  }
		})

		var app4 = new Vue({
		  el: '#app-4',
		  data: {
		    todos: [
		      { text: '学习 JavaScript' },
		      { text: '学习 Vue' },
		      { text: '整个牛项目' }
		    ]
		  }
		})

		var app5 = new Vue({
		  el: '#app-5',
		  data: {
		    message: 'Hello Vue.js!'
		  },
		  methods: {
		    reverseMessage: function () {
		      this.message = this.message.split('').reverse().join('')
		    }
		  }
		})

		// 表单双向输入绑定
		var app6 = new Vue({
		  el: '#app-6',
		  data: {
		    message: 'Hello Vue!'
		  }
		})

		// 定义名为 todo-item 的新组件
		Vue.component('todo-item', {
			// todo-item 组件现在接受一个
	  	  // "prop"，类似于一个自定义特性。
	  	  // 这个 prop 名为 todo。
	  	  props: ['todo'],    // 由父作用域传入子组件的数据
		  template: '<li>{{ todo.text }}</li>'
		})

		var app7 = new Vue({
		  el: '#app-7',
		  data: {
		    groceryList: [
		      { id: 0, text: '蔬菜' },
		      { id: 1, text: '奶酪' },
		      { id: 2, text: '随便其它什么人吃的东西' }
		    ]
		  }
		})

		// 我们的数据对象
		var data = { a: 1 }

		// 该对象被加入到一个 Vue 实例中
		var vm = new Vue({
		  data: data
		})

		// 获得这个实例上的属性
		// 返回源数据中对应的字段
		vm.a == data.a // => true

		// 设置属性也会影响到原始数据
		vm.a = 2
		data.a // => 2

		// 只有当实例被创建时 data 中存在的属性才是响应式的
		//使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再_追踪_变化。

		var data = { a: 1 }
		var vm = new Vue({
		  el: '#example_',
		  data: data
		})

		vm.$data === data // => true
		vm.$el === document.getElementById('example') // => true

		// $watch 是一个实例方法
		vm.$watch('a', function (newValue, oldValue) {
		  // 这个回调将在 `vm.a` 改变后调用
		})

		// created 周期钩子
		new Vue({
		  data: {
		    a: 1
		  },
		  created: function () {
		    // `this` 指向 vm 实例
		    console.log('a is: ' + this.a)
		  }
		})
		// => "a is: 1"

		var app8 = new Vue({
			el: '#app-8',
			data: {
				msg: '插值<span></span>'
			}
		})

		var app9 = new Vue({
			el: '#app-9',
			data: {
				// 这里的 Html 不会解析属性值的数据绑定v-bind:id="dynamicId"
				rawHtml: '<span style="color:red"> This should be red.</span>'
			}
		})

		var app10 = new Vue({
			el: '#app-10',
			data: {

			},
			methods:{
				onSubmit: function (e) {
					console.log(e, this);// 这里的this是Vue实例
					return false;
				}
			}
		})

		var app11 = new Vue({
			el: '#app-11',
			data: {
				url: 'http://www.baidu.com',
				message: 'Hello'
			},
			methods: {
				doSomething: function () {
					console.log(this);
					console.log('我被点击了');
				}
			},
			// 计算属性
			computed: {
				reserveMessage: function () {
					// this 指向vm实例
					return this.message.split('').reserve().join('');
				}
			}
		})

		var example = new Vue({
			el: '#example',
			data: {
				url: 'http://www.baidu.com',
				message: 'Hello'
			},
			methods: {
				doSomething: function () {
					console.log('我被点击了');
				}
			},
			// 计算属性
			computed: {
				reversedMessage: function () {
					// this 指向vm实例，reversedMessage 的值始终取决于message 的值
					return this.message.split('').reverse().join('');
				},
				now: function () {
					return Date.now();
				}
			},
			methods: {
				now: function () {
					console.log(Date.now());
					return Date.now();
				}
			}
		})

	  // 侦听属性
	  // 相同dom的实例化不能共存
		var demo = new Vue({
		  el: '#demo',
		  data: {
		    firstName: 'Foo',
		    lastName: 'Bar',
		    fullName: 'Foo Bar'
		  },
		  watch: {
		    firstName: function (val) {
		      this.fullName = val + ' ' + this.lastName
		    },
		    lastName: function (val) {
		      this.fullName = this.firstName + ' ' + val
		    }
		  }
		})

		var demo2 = new Vue({
		  el: '#demo',
		  data: {
		    firstName: 'Foo',
		    lastName: 'Bar'
		  },
		  computed: {// 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter,
		  	//运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。
		    fullName: {
		      // getter
		      get: function () {
		        return this.firstName + ' ' + this.lastName
		      },
		      // setter
		      set: function (newValue) {
		        var names = newValue.split(' ')
		        this.firstName = names[0]
		        this.lastName = names[names.length - 1]
		      }
		    }
		  }
		})


		var watchExampleVM = new Vue({
		  el: '#watch-example',
		  data: {
		    question: '',
		    answer: 'I cannot give you an answer until you ask a question!'
		  },
		  watch: {
		    // 如果 `question` 发生改变，这个函数就会运行
		    question: function (newQuestion, oldQuestion) {
		      this.answer = 'Waiting for you to stop typing...'
		      this.getAnswer()
		    }
		  },
		  methods: {
		    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
		    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
		    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
		    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
		    // 请参考：https://lodash.com/docs#debounce
		    getAnswer: _.debounce(
		      function () {
		        if (this.question.indexOf('?') === -1) {
		          this.answer = 'Questions usually contain a question mark. ;-)'
		          return
		        }
		        this.answer = 'Thinking...'
		        var vm = this
		        axios.get('https://yesno.wtf/api')
		          .then(function (response) {
		            vm.answer = _.capitalize(response.data.answer)
		          })
		          .catch(function (error) {
		            vm.answer = 'Error! Could not reach the API. ' + error
		          })
		      },
		      // 这是我们为判定用户停止输入等待的毫秒数
		      500
		    )
		  }
		})

		var app12 = new Vue({
			el: '#app-12',
			data: {
				isActive: true,
				hasError: 2,
				activeClass: 'active',
				errorClass: 'text-danger'
			}
		})

		Vue.component('my-component', {
		  template: '<p class="foo bar">Hi</p>'
		})

		var app13 = new Vue({
			el: '#app-13',
			data: {
				activeColor: 'red',
				fontSize: 30,
				styleObject: {
				    color: 'red',
				    fontSize: '13px'
			    },
			    baseStyles: {
			    	color: 'red',
			    	border: '1px solid black'
			    },
			    overridingStyles: {
			    	background: "#f0f"
			    }
			}
		})

		var app14 = new Vue({
			el: '#app-14',
			data:　{
				ok: 4 ? 3 : '',
				type: 'B'
			}
		})

		var app15 = new Vue({
			el: '#app-15',
			data: {
				loginType: 'username'
			},
			methods: {
				toggleLogin: function () {
					this.loginType = this.loginType === 'username' ? 'email' : 'username';
				}
			}
		})

		Vue.component('my-componennt', {
			template: '<div style="height:50px;border: 2px solid red"></div>'
		})

		var app16 = new Vue({
			el: '#app-16',
			data: {
				loginType: 'username',
				ok: true,
			},
			methods: {
				toggleLogin: function () {
					this.loginType = this.loginType === 'username' ? 'email' : 'username';
				}
			}
		})

		var app17 = new Vue({
			el: '#app-17',
			data: {
				parentMessage: "Parent",
				items: [
					{message: "Foo"},
					{message: "Bar"}
				],
				object: {
					firstName: 'John',
					lastName: 'Doe',
					age: '38'
				},
				userProfile: {

				}
			}
		})
		// 数组变异方法
		/*
			Array.push()
			Array.pop()
			Array.shift() 删除第一个
			Array.unshift()
			Array.splice() 向数组添加或删除项
			Array.sort()
			Array.reverse() 
		*/
		app17.items.push({ message: 'Baz' })

		// 非变异的方法
		/*
			Array.filter(function (item) {return item.message.match(/Foo/)})
			Array.concat()
			Array.slice()
		*/
		app17.items = app17.items.filter(function (item) {
		  return item.message.match(/Foo/)
		})

		// app17.items[0] = {message: '6666'}; // 不是响应性的, 由于javascript的限制 ，报错
		// app17.items.length = 5;				// 不是响应性的 报错

		// 解决上述第一种情况
		Vue.set(app17.items, 1, {message: 'newValue'}) 
		// Array.prototype.splice
		app17.items.splice(1, 1, {message: 'newValue'})
		//使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名
		app17.$set(app17.items, 2, {message: 'newValue2'})

		//解决第二类问题，你可以使用 splice
		app17.items.splice(length = 3);

		// 由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除
		app17.b = 3; 				// 不是向应性的

		// 解决方法
		Vue.set(app17.userProfile, 'age', 27)
		//还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名
		app17.$set(app17.userProfile, 'age2', 27)

		// 已有对象赋予多个新属性, 比如使用 Object.assign() 或 _.extend()
		app17.userProfile = Object.assign({}, app17.userProfile, {
		  age3: 27,
		  favoriteColor: 'Vue Green'
		})

		var app18 = new Vue({
			el: '#app-18',
			data: {
				numbers: [1,2,3,4,5]
			},
			computed: {
				evenNumbers: function () {
					return this.numbers.filter(function (number) {
						return number % 2 == 0; // 返回true 或false
					})
				}
			}
		})

		var app19 = new Vue({
			el: '#app-19',
			data: {
				items: [
					{message: 'msg1'},
					{message: 'msg2'},
					{message: 'msg3'}
				],
				todos: [
					{isComplete: false},
				]
			}
		})

		// 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。

		Vue.component('todo-item', {
		  template: '\
		    <li>\
		      {{ title }}\
		      <button v-on:click="$emit(\'remove\')">X</button>\
		      <button>{{ titleModify }}</button>\
		    </li>\
		  ',
		  props: ['title'],
		  data: function () {
		  	return {
		  		key: 4444
		  	}
		  },
		  computed: {
		  	titleModify: function () {
		  		return this.title + 'modify' +this.key;
		  	}
		  }
		})

		new Vue({
		  el: '#todo-list-example',
		  data: {
		    newTodoText: '',
		    todos: [
		      {
		        id: 1,
		        title: 'Do the dishes',
		      },
		      {
		        id: 2,
		        title: 'Take out the trash',
		      },
		      {
		        id: 3,
		        title: 'Mow the lawn'
		      }
		    ],
		    nextTodoId: 4
		  },
		  methods: {
		    addNewTodo: function () {
		      this.todos.push({
		        id: this.nextTodoId++,
		        title: this.newTodoText
		      })
		      this.newTodoText = ''
		    }
		  }
		})

		var example1 = new Vue({
		  el: '#example-1',
		  data: {
		    name: 'Vue.js',
		    counter: 0
		  },
		  // 在 `methods` 对象中定义方法
		  methods: {
		    greet: function (event) {
		      // `this` 在方法里指向当前 Vue 实例
		      alert('Hello ' + this.name + '!')
		      // `event` 是原生 DOM 事件
		      if (event) {
		        alert(event.target.tagName)
		      }
		    },
		    say: function (event, message) {
		    	console.log("1108say", event)
	          alert(message)
	        },
	        warn: function (message, event) {
	           // 现在我们可以访问原生事件对象
	           if (event) event.preventDefault()
	           alert(message)
	         }
		  }
		})

		// 也可以用 JavaScript 直接调用方法
		example1.greet(); //

		// 可以通过全局 config.keyCodes 对象自定义按键修饰符别名：
		// 可以使用 `v-on:keyup.f1`
		Vue.config.keyCodes.f1 = 112

		var app21 = new Vue({
			el: '#app-21',
			data: {
				message: '',
				checkedNames: [],
				picked: '',
				selected: '',
				selectedMul: [],
				selectedVFor: 'A',
				options: [
					{text: 'One', value: 'A'},
					{text: 'Two', value: 'B'},
					{text: 'Three', value: 'C'}
				],
				toggle: '',
				checked: '',
				pick: '',
				a: 'a',
				msg: '',
				age: 33,
				msgs: ''
			}
		})

		//全局注册

		// 先注册组件，后创建根实例
		Vue.component('my-component', {
		  // 选项
		})
		// new Vue({
		//   el: '#some-element',
		//   // 选项
		// })

		// 局部注册
		var Child = {
		  template: '<div>A custom component!</div>'
		}
		new Vue({
		  // ...
		  components: {
		    // <my-component> 将只在父组件模板中可用
		    'my-component': Child
		  }
		})

		// 组件data必须是函数
		var data = { counter: 0 }

		Vue.component('simple-counter', {
		  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
		  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
		  // 但是我们却给每个组件实例返回了同一个对象的引用
		  data: function () {
		    return data
		  },
		  // 修正版
		  // data: function () {
		  //   return {
		  //     counter: 0
		  //   }
		  // }
		})
		var app23 = new Vue({
  			el: '#example-2'
		})

		// 使用 Prop 向子组件传递数据
		// <parent-component>
		// 	<child-component message="msg"></child-component>
		// </parent-component>
		/*
			Vue.component('child-component', {
			  // 声明 props
			  props: ['message'],
			  // 就像 data 一样，prop 也可以在模板中使用
			  // 同样也可以在 vm 实例中通过 this.message 来使用
			  template: '<span>{{ message }}</span>'
			})
		*/

		// 子组件中接受的props用camalCase, html中属性用kebab-case命名
		Vue.component('child', {
		  // 在 JavaScript 中使用 camelCase
		  props: ['myMessage'],   
		  template: '<span>{{ myMessage }}</span>'
		})

		var app24 = new Vue({
			el: '#app-24',
			data: {

			}
		})


		Vue.component("todo-item", {
			template: '<span>{{ text }} {{ isComplete }} {{ counter }}</span>',
			props: ['text', 'isComplete'],
			data: function () {
			  return { counter: this.text + 'kkkkkkkk' }
			}
		})

		// 动态 Prop
		var app25 = new Vue({
		  el: '#app-25',
		  data: {
		    parentMsg: 'Message from parent',
		    todo: {
		      text: 'Learn Vue',
		      isComplete: false
		    }
		  }
		})
		// 如果你想把一个对象的所有属性作为 prop 进行传递，可以使用不带任何参数的 v-bind (即用 v-bind 而不是 v-bind:prop-name)。例如，已知一个 todo 对象：

		// props 验证
		/*
			type 也可以是一个自定义构造器函数，使用 instanceof 检测：
			String
			Number
			Boolean
			Function
			Object
			Array
			Symbol
		*/
		// 注意 prop 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用

		Vue.component('example-validator', {
			template: "<span value='nihao2' class='form-control'> {{ propA }}</span>",
			props: ['propA', 'propB']
		  // props: {
		  //   // 基础类型检测 (`null` 指允许任何类型)
		  //   propA: {
		  //   	type:Number,
		  //   	default: 44444
		  //   },
		  //   // 可能是多种类型
		  //   propB: [String, Number],
		  //   // 必传且是字符串
		  //   // propC: {
		  //   //   type: String,
		  //   //   required: true
		  //   // },
		  //   // // 数值且有默认值
		  //   // propD: {
		  //   //   type: Number,
		  //   //   default: 100
		  //   // },
		  //   // // 数组/对象的默认值应当由一个工厂函数返回
		  //   // propE: {
		  //   //   type: Object,
		  //   //   default: function () {
		  //   //     return { message: 'hello' }
		  //   //   }
		  //   // },
		  //   // // 自定义验证函数
		  //   // propF: {
		  //   //   validator: function (value) {
		  //   //     return value > 10
		  //   //   }
		  //   // }
		  // }
		})

		var exampleValidator = new Vue({
			el: '#app-26',
			data: {

			}
		})

		// 使用 v-on 绑定自定义事件
		// 每个 Vue 实例都实现了事件接口，即：
		/*
			使用 $on(eventName) 监听事件
			使用 $emit(eventName, optionalPayload) 触发事件
		*/

		Vue.component('button-counter', {
		  template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
		  data: function () {
		    return { // 此处返回的对象向会合并到props中
		      counter: 0
		    }
		  },
		  methods: {
		    incrementCounter: function () {
		      this.counter += 1
		      this.$emit('increment')
		    }
		  },
		})

		var countereventexample = new Vue({
		  el: '#counter-event-example',
		  data: {
		    total: 0
		  },
		  methods: {
		    incrementTotal: function () {
		      this.total += 1
		    }
		  }
		})

		// 子组件绑定事件，改变子组件数据，然后this.$emit('message', {message: this.message})
		// 父组件绑定自定义事件（v-on:message='handleMessag'）, 然后接受子组件传入的参数改变相关数据
		Vue.component('button-message', {
		  template: `<div>
		    <input type="text" v-model="message" />
		    <button v-on:click="handleSendMessage">Send</button>
		  </div>`,
		  data: function () {
		    return {
		      message: 'test message'
		    }
		  },
		  methods: {
		    handleSendMessage: function () {
		      this.$emit('message', { message: this.message })
		    }
		  }
		})

		var messageeventexample = new Vue({
		  el: '#message-event-example',
		  data: {
		    messages: []
		  },
		  methods: {
		    handleMessage: function (payload) {
		      this.messages.push(payload.message)
		    }
		  }
		})


		Vue.component('currency-input', {
		  template: '\
		    <span>\
		      $\
		      <input\
		        ref="input"\
		        v-bind:value="value"\
		        v-on:input="updateValue($event.target.value)"\
		      >\
		    </span>\
		  ',
		  props: ['value'],
		  methods: {
		    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制
		    updateValue: function (value) {console.log(value);
		      var formattedValue = value
		        // 删除两侧的空格符
		        .trim()
		        // 保留 2 位小数
		        .slice(
		          0,
		          value.indexOf('.') === -1
		            ? value.length
		            : value.indexOf('.') + 3
		        )
		      // 如果值尚不合规，则手动覆盖为合规的值
		      if (formattedValue !== value) {
		        this.$refs.input.value = formattedValue
		      }
		      // 通过 input 事件带出数值
		      this.$emit('input', Number(formattedValue))
		    }
		  }
		})

		var app28 = new Vue({
			el: '#app-28',
			data: {
				price:''
			}
		})


		// 自定义组件的 v-model
		Vue.component('my-checkbox', {
		  model: {
		    prop: 'checked',
		    event: 'change'
		  },
		  props: {
		    checked: Boolean,
		    // 这样就允许拿 `value` 这个 prop 做其它事了
		    value: String
		  },
		  // ...
		  template: '<div><input v-bind:value="value" @change="handlerChanged" /><span>{{ checked }}</span></div>',
		  methods: {
		  	handlerChanged: function (val) {
		  		this.$emit('change', this.value)
		  	}
		  }
		})

		var app29 = new Vue({
			el: '#app-29',
			data: {
				foo: false,
			},
			methods: {
				handlerChanged: function (val) {
					this.foo = val;
				}
			}
		})

		// 非父子组件的通信
		var bus = new Vue();
		Vue.component('brathor1', {
			template: '<button @click="eventA" >brathor1</button>',
			props: [],
			data: function () {
				return {}
			},
			methods: {
				eventA: function () {
					console.log('click button A')
					bus.$emit('changeA', 'hhhhhh')
				}
			}
		})

		Vue.component('brathor2', {
			template:'<button>brathor2{{ msg }}</button>',
			created () {
				bus.$on('changeA', (msg, event) => {
					console.log(msg, event);
					this.msg = msg;
				})
			},
			data: function () {
				return {
					msg: 'init'
				}
			},
			methods: {
				handlerChangeA: function () {

				}
			}

		})

		var app30 = new Vue({
			el: '#app-30',
			data: {

			}
		})

		// 使用插槽分发内容
		//单个插槽
		     //子组件，备用内容在子组件的作用域内编译，并且只有在宿主元素为空时，且没有要插入的内容时才显示备用内容
		      Vue.component('child-com',{
		          template:'<div><h2>我是子组件的标题</h2>' +
		          '<slot>只有在没有要分发的内容时才会显示</slot>' +
		          '</div>'
		      });
		      //父组件
		     Vue.component('my-com',{
		         template:'<div><h1>我是父组件的标题</h1>' +
		         '<child-com>' +
		         '<p>这是一些初始内容</p>' +
		         '<p>这是另外一些初始内容</p>' +
		         '</child-com>' +
		         '</div>'
		     });
		     var app31 = new Vue({
		         el:'#app-31'
		     })

		     // 具名插槽
		     //子组件
		     Vue.component('app-layout',{
		         template:'' +
		         '<div class="container">' +
		         '   <header>' +
		         '       <slot name="header"></slot>' +
		         '   </header>' +
		         '   <main>' +
		         '       <slot></slot>' +
		         '   </main>' +
		         '   <footer>' +
		         '       <slot name="footer"></slot>' +
		         '   </footer>' +
		         '</div>'
		     });
		     //父组件
		     Vue.component('parent-com',{
		         template:'' +
		         '<app-layout>' +
		         '   <h1 slot="header">这是一个页面的标题</h1>' +
		         '   <p>主要内容的一个段落</p>' +
		         '   <p>主要内容的另外一个段落</p>' +
		         '   <p slot="footer">这是一些页脚信息</p>' +
		         '</app-layout>'
		     });
		     var app32 = new Vue({
		         el:'#app-32'
		     })

		     //子组件
		          //代表性的列表组件模块
		          Vue.component('child-com2',{
		              template:'' +
		              '<ul>' +
		              '   <slot name="child-ul" v-for="item in animal" v-bind:text="item.name"></slot>' +
		              '</ul>',
		              data:function(){
		                  return {
		                      animal:[
		                          {name:'大象'},
		                          {name:'小狗'},
		                          {name:'小猫'},
		                          {name:'老虎'}
		                      ]
		                  }
		              }
		          });
		          //父组件
		          // 在父组件的模板里，使用一个Vue自带的特殊组件<template> ，
		          // 并在该组件上使用scope属性，值是一个临时的变量，存着的是由子组件传过来的
		          // prop对象，在下面的例子中我把他命名为props。
		          //  获得由子传过来的prop对象。这时候，父组件就可以访问子组件在自定义属性上暴露的数据了。
		         Vue.component('parent-com2',{
		             template:'' +
		             '<div class="container">' +
		             '<p>动物列表</p>' +
		             '<child-com2>' +
		             '   <template scope="props" slot="child-ul">' +
		             '       <li class="child-ul">{{ props.text }}</li>' +
		             '   </template>' +
		             '</child-com2>' +
		             '</div>'
		         });
		         //这个<div class="container"></div>是必须的，不然会发生编译错误
		         var app33 = new Vue({
		             el:'#app-33'
		         })
// ###########################################################
// 组件嵌套 两种方式 插槽 、流式		         
		    Vue.component('parent', {
		    	template: '<div>父组件<slot></slot></div>'
		    })
		    Vue.component('child', {
		    	template: '<div>子组件<slot></slot></div>'
		    })
		    Vue.component('grandson', {
		    	template: '<div>仔仔组件</div>'
		    })

		    var app34 = new Vue({
		    	el: '#app-34',
		    })

		    Vue.component("parent1",{
		    	template: '<div>父组件<child1>子组件</child1></div>'
		    })
		    Vue.component('child1', {
		    	template: '<div>子组件<grandson1></grandson1></div>'
		    })
		    Vue.component('grandson1', {
		    	template: '<div>仔仔组件</div>'
		    })
		    var app35 = new Vue({
		    	el: "#app-35"
		    })
// ###########################################		    

		// 动态组件
		var app36 = new Vue({
		  el: '#app-36',
		  data: {
		    currentView: 'home'
		  },
		  components: {
		    home: { 
		    	template: "<span>home</span>"
		    },
		    posts: { /* ... */ },
		    archive: { /* ... */ }
		  }
		})

		// 	自模版直接绑定到组件对象上
		var Home = {
		  template: '<p>Welcome home!</p>'
		}
		var app37 = new Vue({
		  el: '#app-37',
		  data: {
		    currentView: Home
		  }
		})

		// keep-alive 
		var app38 = new Vue({
			el: '#app-38', 
			data: {
				currentView: {
					template: '<p>Welcome keep-alive Home!</p>'
				}
			}
		})

		// 编写可复用的组件
		// Vue 组件的 API 来自三部分——prop、事件和插槽：


		// 子组件引用
		var app39 = new Vue({ 
			el: '#app-39', 
			components: {
				'user-profile': {
					template: '<div>我是局部组件，通过ref可以获取我</div>'
				}
			}
		})
		// 访问子组件实例
		var app39child = app39.$refs.profile;console.log(app39child);

		// 异步组件
		// Vue.js 允许将组件定义为一个工厂函数，异步地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染

		Vue.component('async-example', function (resolve, reject) {
		  setTimeout(function () {
		    // 将组件定义传入 resolve 回调函数
		    resolve({
		      template: '<div>I am async!</div>'
		    })
		  }, 5000)
		})
		var app40 = new Vue({
			el: "#app-40",
		})


		// 	推荐配合 webpack 的代码分割功能 来使用：
		Vue.component('async-webpack-example', function (resolve) {
		  // 这个特殊的 require 语法告诉 webpack
		  // 自动将编译后的代码分割成不同的块，
		  // 这些块将通过 Ajax 请求自动下载。
		  require(['./my-async-component'], resolve)
		})

		// 你可以在工厂函数中返回一个 Promise，所以当使用 webpack 2 + ES2015 的语法时可以这样：
		Vue.component(
		  'async-webpack-example',
		  // 该 `import` 函数返回一个 `Promise` 对象。
		  () => import('./my-async-component')
		)

		// 当使用局部注册时，也可以直接提供一个返回 Promise 的函数：
		new Vue({
		  // ...
		  components: {
		    'my-component__': () => import('./my-async-component')
		  }
		})

		/// 高级异步组件 2.3.0 新增   自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象：
		const AsyncComp = () => ({
		  // 需要加载的组件。应当是一个 Promise
		  component: import('./MyComp.vue'),
		  // 加载中应当渲染的组件
		  loading: LoadingComp,
		  // 出错时渲染的组件
		  error: ErrorComp,
		  // 渲染加载中组件前的等待时间。默认：200ms。
		  delay: 200,
		  // 最长等待时间。超出此时间则渲染错误组件。默认：Infinity
		  timeout: 3000
		})

		// 注意：异步组件被作为 vue-router 的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件

		// 组件命名约定
		/*
			注册组件 (或者 prop) 时，可以使用
			 kebab-case (短横线分隔命名)
			 camelCase (驼峰式命名) 
			 PascalCase (单词首字母大写命名)。
			 // 在组件定义中
			 components: {
			   // 使用 kebab-case 注册
			   //'kebab-cased-component': { ... },
			   // 使用 camelCase 注册
			   //'camelCasedComponent': { ... },
			   // 使用 PascalCase 注册
			   //'PascalCasedComponent': { ... }
			// }
		*/
		/*
			<!-- 在 HTML 模板中始终使用 kebab-case -->
			<kebab-cased-component></kebab-cased-component>
			<camel-cased-component></camel-cased-component>
			<pascal-cased-component></pascal-cased-component>
		*/
		/*
			如果组件未经 slot 元素传入内容，你甚至可以在组件名后使用 / 使其自闭合：

			<my-component/>

		*/

		// 递归组件
		/*
			组件在它的模板内可以递归地调用自己。不过，只有当它有 name 选项时才可以这么做：
			name: 'unique-name-of-my-component'
		*/

		// 组件间的循环引用
		Vue.component('tree-folder-contents', {
			name: 'contentstree',
			template:   '<ul>' +
								'<li v-for="child in children">'+
								'<tree-folder v-if="child.children" :folder="child"/>' +
								'<span v-else>{{ child.name }}</span>' +
								'</li>' +
						'</ul>',
			props: ['children']
		})
		Vue.component('TreeFolder', {
			name: 'jjjj9999',
			template: 	'<p>' + 
							'<span>{{ folder.name }}</span>' +
							'<tree-folder-contents :children="folder.children" ref="treefoldercontents"/>' +
						'</p>',
			beforeCreate: function () {
				this.$options.components.TreeFolderContents = this.$refs.treefoldercontents; //require('./tree-folder-contents.vue').default
			},
			data: function () {
				return {
					folder: {
						name: '组件TreeFolder',
						children: [
							// {
							// 	children: {
							// 		name: '第二轮floder',
							// 		// children: [
							// 		// 	{children:'', name: 'xiaoming'},
							// 		// 	{children: '', name: 'xiaoliang'}
							// 		// ]
							// 	},
							// 	name: "第一组"
							// },
							{
								children: {
									name: '小红被淘汰',
									// children: [
									// 	{children: '', name: '火箭'},
									// 	{children: '', name: '导弹'}
									// ]
								},
								name: '第二组'
							}
						]
					}
				}
			}
		})

		/*var app41 = new Vue({
			el: '#app-41',
			data: {
				
			},
			components: {
				// TreeFolder: {
				// 	name: 'jjjj9999',
				// 	template: 	'<p>' + 
				// 					'<span>{{ folder.name }}</span>' +
				// 					'<tree-folder-contents :children="folder.children"/>' +
				// 				'</p>',
				// 	data: function () {
				// 		return {
				// 			folder: {
				// 				name: '组件TreeFolder',
				// 				children: [
				// 					{
				// 						children: {
				// 							name: '第二轮floder',
				// 							children: [
				// 								{children:'', name: 'xiaoming'},
				// 								{children: '', name: 'xiaoliang'}
				// 							]
				// 						},
				// 						name: "第一组"
				// 					},
				// 					{
				// 						children: {
				// 							name: '小红被淘汰',
				// 							children: [
				// 								{children: '', name: '火箭'},
				// 								{children: '', name: '导弹'}
				// 							]
				// 						},
				// 						name: '第二组'
				// 					}
				// 				]
				// 			}
				// 		}
				// 	},
				// 	// components: {
				// 	// 	name: 'tttttt6666666',
				// 	// 	'tree-folder-contents': {
				// 	// 		template:   '<ul>' +
  		// 	// 								'<li v-for="child in children">'+
    // 	// 										'<tree-folder v-if="child.children" :folder="child"/>' +
    // 	// 										'<span v-else>{{ child.name }}</span>' +
  		// 	// 								'</li>' +
				// 	// 					'</ul>',
				// 	// 		props: ['children']
				// 	// 	}
				// 	// }
				// },
			},
			// components: {
			// 	'tree-folder-contents': {
			// 		template:   '<ul>' +
			// 							'<li v-for="child in children">'+
			// 							'<tree-folder v-if="child.children" :folder="child"/>' +
			// 							'<span v-else>{{ child.name }}</span>' +
			// 							'</li>' +
			// 					'</ul>',
			// 		props: ['children']
			// 	}
			// }
		})*/

		// 内联模板
		var app42 = new Vue({
			el: '#app-42',
			data: function () {
				return {}
			},
			components: {
				'myComponent': {
					template: '<div>我是组件模版1922行</div>' // 使用inline-template指令后定义的组件字符串不起作用
				}
			}
		})

		// X-Template
		Vue.component('hello-world', {
		  template: '#hello-world-template'
		})

		// 当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来
		Vue.component('terms-of-service', {
		  template: '\
		    <div v-once>\
		      <h1>Terms of Service</h1>\
		      ...很多静态内容...\
		    </div>\
		  '
		})

		// 组件命名规范
		/*
			使用 kebab-case
				定义：Vue.component('my-component-name', { ... })
				引用：<my-component-name>

			使用 PascalCase
				定义：Vue.component('MyComponentName', { ... })
				引用；字符串模版引用 
						<my-component-name>、<MyComponentName>
					  dom中直接引用
					  	<my-component-name>

		*/

		// 全局注册的组件在webpack这样的构建系统中会造成最总的文件无谓的增加，局部注册可以避免这种情况
		// 注册局部组件
		var ComponentA = { /* ... */ }
		var ComponentB = { /* ... */ }
		var ComponentC = { /* ... */ }
		new Vue({
		  el: '#app',
		  components: {
		    'component-a': ComponentA,
		    'component-b': ComponentB
		  }
		})

		// 注意局部注册的组件在其子组件中不可用
		// 如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：
		var ComponentA = { /* ... */ }
		var ComponentB = {
		  components: {
		    'component-a': ComponentA
		  },
		  // ...
		}
		/*
			// es2015写法
			import ComponentA from './ComponentA.vue'

			export default {
			  components: {
			    ComponentA
			  },
			  // ...
			}
		*/

		// 在模块系统中局部注册
		/*
			import ComponentA from './ComponentA'
			import ComponentC from './ComponentC'

			export default {
			  components: {
			    ComponentA,
			    ComponentC
			  },
			  // ...
			}
		*/


		// 基础组件的自动化全局注册
		/*
			如果你使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：

			import Vue from 'vue'
			import upperFirst from 'lodash/upperFirst'
			import camelCase from 'lodash/camelCase'

			const requireComponent = require.context(
				// 其组件目录的相对路径
				'./components',
				// 是否查询其子目录
				false,
				// 匹配基础组件文件名的正则表达式
				/Base[A-Z]\w+\.(vue|js)$/
			)

			requireComponent.keys().forEach(fileName => {
			  	// 获取组件配置
			  	const componentConfig = requireComponent(fileName)

			  	// 获取组件的 PascalCase 命名
			  	const componentName = upperFirst(
			    	camelCase(
			      	// 剥去文件名开头的 `'./` 和结尾的扩展名
			      	fileName.replace(/^\.\/(.*)\.\w+$/, '$1')
			    	)
			  	)

			  	// 全局注册组件
			  	Vue.component(
				    componentName,
				    // 如果这个组件选项是通过 `export default` 导出的，
				    // 那么就会优先使用 `.default`，
				    // 否则回退到使用模块的根。
				    componentConfig.default || componentConfig
			  	)
			})
		*/

		var app43 = new Vue({
		  el: '#app-43',
		  data: {
		    show: true
		  }
		})

		// 
		var app44 = new Vue({
		  el: '#app-44',
		  data: {
		    show: true
		  }
		})

		//
		var app45 = new Vue({
		  el: '#app-45',
		  data: {
		    show: true
		  }
		})

		var app46 = new Vue({
		  	el: '#app-46',
		  	data: {
		    	show: true
		  	}
		})

		var app47 = new Vue({
		  	el: '#app-47',
		  	data: {
		    	show: true
		  	}
		})

		/*
			注意：当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成

			推荐：对于仅使用 JavaScript 过渡的元素添加 v-bind:css="false"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。
		*/
		var app48 = new  Vue({
			el: '#app-48',
			data: {
				show: true
			},
			methods: {
			  // --------
			  // 进入中
			  // --------

			  beforeEnter: function (el) {
			    // ...
			    console.log('进入之前', el);
			  },
			  // 此回调函数是可选项的设置
			  // 与 CSS 结合时使用
			  enter: function (el, done) {
			    // ...
			    done()
			    console.log('进入之时', el);
			  },
			  afterEnter: function (el) {
			    // ...
			    console.log('进入之后', el);
			  },
			  enterCancelled: function (el) {
			    // ...
			    console.log('进入销毁', el);
			  },

			  // --------
			  // 离开时
			  // --------

			  beforeLeave: function (el) {
			    // ...
			    console.log('离开之前', el);
			  },
			  // 此回调函数是可选项的设置
			  // 与 CSS 结合时使用
			  leave: function (el, done) {
			    // ...
			    done()
			    console.log('离开之时', el);
			  },
			  afterLeave: function (el) {
			    // ...
			    console.log('离开之后', el);
			  },
			  // leaveCancelled 只用于 v-show 中
			  leaveCancelled: function (el) {
			    // ...
			    console.log('离开销毁', el);	
			  }
			}
		})
		
		// Velocity.js 简单例子
		var app49 = new Vue({
			el: '#app-49',
			data: {
			  show: true
			},
		  	methods: {
			    beforeEnter: function (el) {
			      el.style.opacity = 0
			      el.style.transformOrigin = 'left'
			    },
			    enter: function (el, done) {
			      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })
			      Velocity(el, { fontSize: '1em' }, { complete: done })
			    },
			    leave: function (el, done) {
			      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })
			      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })
			      Velocity(el, {
			        rotateZ: '45deg',
			        translateY: '30px',
			        translateX: '30px',
			        opacity: 0
			      }, { complete: done })
			    }
			}
		})

		// 自定已javascript钩子
		var app50 = new Vue({
			el: '#app-50',
			data: {
			  show: true
			},
		  	methods: {
			    customBeforeAppearHook: function (el) {
			    	console.log("初始渲染之beforeEnter", el)
			      el.style.opacity = 0
			      el.style.transformOrigin = 'left'
			    },
			    customAppearHook: function (el, done) {
			    	console.log('初始渲染之enter', el)
			      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })
			      Velocity(el, { fontSize: '1em' }, { complete: done })
			    },
			    customAfterAppearHook: function (el, args2) {
			    	console.log('进入之后', el, args2);
			    },
			    customAppearCancelledHook: function (el, args2) {
			    	console.log('进入销毁', el, args2);
			    },
			    leave: function (el, done) {
			      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })
			      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })
			      Velocity(el, {
			        rotateZ: '45deg',
			        translateY: '30px',
			        translateX: '30px',
			        opacity: 0
			      }, { complete: done })
			    }
			}
		})

		// 
		var app51 = new Vue({
			el: '#app-51',
			data: {
				isEditing: false,
				isEditingDymanical: 'SaveD',
				docState: 'edited',
				items: [2,3,4,5],
				show: true
			},
			computed: {
				buttonMessage: function () {
					switch (this.docState) {
					    case 'saved': return 'Edit'
					    case 'edited': return 'Save'
					    case 'editing': return 'Cancel'
					}
				}
			}
		})

		var app52 = new Vue({
			el: '#app-52',
			data: {
				on: true,
				docState: 'jskjddkf'
			},
			computed: {
				show: function () {  // 计算属性没有setter
					return this.on;
				}
			}
		})

		var app53 = new Vue({
			el: '#app-53', 
			data: {
				on: true
			},
			computed: {

			},
			methods: {
				change: function (event) {
					console.log('2644', 'in-out')
					this.on = !this.on;
				}
			}
		})

		var app54 = new Vue({
			el: '#app-54', 
			data: {
				on: true
			},
			computed: {

			},
			methods: {
				change: function (event) {
					console.log('2679', 'in-out_translate')
					this.on = !this.on;
				}
			}
		})

		// 使用动态组件实现多个组件的过渡
		var app55 = new Vue({
		  	el: '#app-55',
		  	data: {
		    	view: 'v-a'
		  	},
		  	components: {
		    	'v-a': {
		      	template: '<div>Component A</div>'
		    	},
		    	'v-b': {
		      	template: '<div>Component B</div>'
		    	}
		  	},
		  	methods: {
		  		change: function () {
		  			this.view = this.view === "v-a" ? "v-b" : "v-a";
		  		}
		  	}
		})

		var app56 = new Vue({
			el: '#app-56',
			  data: {
			    items: [1,2,3,4,5,6,7,8,9],
			    nextNum: 10
			  },
			  methods: {
			    randomIndex: function () {
			      return Math.floor(Math.random() * this.items.length)
			    },
			    add: function () {
			      this.items.splice(this.randomIndex(), 0, this.nextNum++)
			    },
			    remove: function () {
			      this.items.splice(this.randomIndex(), 1)
			    },
			  }
		})

		var app57 = new Vue({
			el: '#app-57',
			  data: {
			    items: [1,2,3,4,5,6,7,8,9]
			  },
			  methods: {
			    shuffle: function () {
			      this.items = _.shuffle(this.items)
			    }
			  }
		})

		var app58 = new Vue({
		  	el: '#app-58',
		  	data: {
		  	  items: [1,2,3,4,5,6,7,8,9],
		  	  nextNum: 10
		  	},
		  	methods: {
		  	  	randomIndex: function () {
		  	  	  return Math.floor(Math.random() * this.items.length)
		  	  	},
		  	  	add: function () {
		  	  	  this.items.splice(this.randomIndex(), 0, this.nextNum++)
		  	  	},
		  	  	remove: function () {
		  	  	  this.items.splice(this.randomIndex(), 1)
		  	  	},
		  	  	shuffle: function () {
		  	  	  this.items = _.shuffle(this.items)
		  	  	}
		  	}
		})

		var app59 = new Vue({
		  	el: '#app-59',
		  	data: {
		    	cells: Array.apply(null, { length: 81 })
		      	.map(function (_, index) {
		        	return {
		          	id: index,
		          	number: index % 9 + 1
		        	}
		      	})
		  	},
		  	methods: {
		    	shuffle: function () {
		      		this.cells = _.shuffle(this.cells)
		    	}
		  	}
		})

		// 
		Vue.component('my-special-transition', {
		  template: '\
		    <transition\
		      name="very-special-transition"\
		      mode="out-in"\
		      v-on:before-enter="beforeEnter"\
		      v-on:after-enter="afterEnter"\
		    >\
		      <slot ></slot>\
		    </transition>\
		  ',
		  props: ['component_on'],
		  methods: {
		    beforeEnter: function (el) {
		      // ...
		      console.log('可复用组件的过渡之beforEnter', el)
		    },
		    enter: function(el, done) {
		    	var delay = el.dataset.index * 150 || 1000
		    	setTimeout(function () {console.log(2974, '执行了')
		    	  	Velocity(
		    	  	  	el,
		    	  	  	{ opacity: 1, height: '1.6em' },
		    	  	  	{ complete: done }
		    	  	)
		    	}, delay)
		    },
		    afterEnter: function (el) {
		      // ...
		      console.log('可复用组件的过渡之afterEnter', el)
		    }
		  }
		})

		var app60 = new Vue({
			el: '#app-60', 
			data: {
				on: true,

			},
			methods: {
				change: function(){
					this.on = !this.on;
				}
			}
		})


		var app61 = new Vue({
		  	el: '#app-61',
		  	data: {
		  	  	query: '',
		  	  	list: [
		  	  	  	{ msg: 'Bruce Lee' },
		  	  	  	{ msg: 'Jackie Chan' },
		  	  	  	{ msg: 'Chuck Norris' },
		  	  	  	{ msg: 'Jet Li' },
		  	  	  	{ msg: 'Kung Fury' }
		  	  	]
		  	},
		  	computed: {
		  	  	computedList: function () {
		  	  	  	var vm = this
		  	  	  	return this.list.filter(function (item) {
		  	  	  	  	return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
		  	  	  	})
		  	  	}
		  	},
		  	methods: {
		  	  	beforeEnter: function (el) {
		  	  	  	el.style.opacity = 0
		  	  	  	el.style.height = 0
		  	  	},
		  	  	enter: function (el, done) {
		  	  	  	var delay = el.dataset.index * 150
		  	  	  	setTimeout(function () {
		  	  	  	  	Velocity(
		  	  	  	  	  	el,
		  	  	  	  	  	{ opacity: 1, height: '1.6em' },
		  	  	  	  	  	{ complete: done }
		  	  	  	  	)
		  	  	  	}, delay)
		  	  	},
		  	  	leave: function (el, done) {
		  	  	  	var delay = el.dataset.index * 150
		  	  	  	setTimeout(function () {
		  	  	  	  	Velocity(
		  	  	  	  	  	el,
		  	  	  	  	  	{ opacity: 0, height: 0 },
		  	  	  	  	  	{ complete: done }
		  	  	  	  	)
		  	  	  	}, delay)
		  	  	}
		  	}
		})

		// 动态过渡
		var app62 = new Vue({
		  el: '#app-62',
		  data: {
		    show: true,
		    fadeInDuration: 1000,
		    fadeOutDuration: 1000,
		    maxFadeDuration: 1500,
		    stop: true
		  },
		  mounted: function () {
		    this.show = false
		  },
		  methods: {
		    beforeEnter: function (el) {
		      el.style.opacity = 0
		    },
		    enter: function (el, done) {
		      var vm = this
		      Velocity(el,
		        { opacity: 1 },
		        {
		          duration: this.fadeInDuration,
		          complete: function () {
		            done()
		            if (!vm.stop) vm.show = false
		          }
		        }
		      )
		    },
		    leave: function (el, done) {
		      var vm = this
		      Velocity(el,
		        { opacity: 0 },
		        {
		          duration: this.fadeOutDuration,
		          complete: function () {
		            done()
		            vm.show = true
		          }
		        }
		      )
		    }
		  }
		})

		/*
			状态过渡包括：
				1、数字和运算
				2、颜色的显示
				3、SVG 节点的位置
				4、元素的大小和其他的属性
		*/

		// 状态动画与侦听器
		var app63 = new Vue({
		  el: '#animated-number-demo',
		  data: {
		    number: 0,
		    tweenedNumber: 0
		  },
		  computed: {
		    animatedNumber: function() {
		      return this.tweenedNumber.toFixed(0);
		    }
		  },
		  watch: {
		    number: function(newValue) {
		      TweenLite.to(this.$data, 0.5, { tweenedNumber: newValue });
		    }
		  }
		})

		Vue.component('component-computed', {
			template: '<span style="font-size:26px">{{ left }}</span>',
			props: [],
			data: function () {
				return {
					top: 34,
					left: '44'
				}
			},
			methods: {
				setleft: function () {
					this.left = this.top;
				}
			}
		})
		var app64 = new Vue({
			el: '#app-64',
		})


	</script>

</body></html>